3-1.인스턴스 필드&NullPointException 발생 이유
- 클래스 메소드 vs 인스턴스 메소드
-> 인스턴스 별로 다르게 동작해야 한다면 인스턴스 메소드
    static메소드는 객체 생성/유틸리티 관련해서 사용될 때가 있음
- 필드는 클래스가 가지는 속성/다른 언어에서는 멤버변수라고도 함
- 필드는 어떤 키워드와 함께 사용하냐에 따라 사용방법이 달라짐
- static이라는 키워드가 함께 사용되는 필드 = 클래스 필드/함께 사용X=인스턴스 필드
- 필드 선언 방법
: [접근제한자][static][final]타입 필드명[=초기값];
(대괄호 안은 생략 가능)
접근 제한자: public, protected, private, default(아무것도 없는 경우)
- 필드명은 식별자 규칙을 따름. 첫번째는 소문자 시작 권장
- 타입은 기본형, 참조타입 가능
- 초기값이 없는 경우, 참조형은 null, boolean형일 경우 false, 나머지 기본값일 경우 0으로 초기화
예) String name;
    String address="경기도 고양시";
    protected boolean flag;
    String은 참조타입->name은 null값을 가짐.
    address는 "경기도 고양시"라는 문자열 인스턴스를 참조함.
    boolean flag는 false를 가짐.

예2) User class 
    public class Person{
        String name;
        String address;
        boolean isVip;
    }
    ->Person클래스는 name, address, isVip 3개의 필드 선언
    cf.문자열은 new를 사용하지 않고 인스턴스 생성 가능(되도록 사용 지양)

3-2.클래스 필드(static필드)
- 클래스 정보는 정적인 상태이므로 다른 참조변수가 같은 이름의 인스턴스를 참조할 경우, 하나의 참조변수를 수정할 경우에도 인스턴스의 상태가 변화함.

3-3.클래스 메소드에서 인스턴스 필드를 사용하지 못하는 이유, static block 사용방법
- staticX = 인스턴스 필드 -> 인스턴스를 만들어야 사용 가능
- static = 클래스 필드 

3-4. main메소드보다 먼저 실행되는 static블록
ex) Hello2.java소스 컴파일 시 java 실행 -> JVM은 CLASSPATH에서 Hello2 클래스 탐색
-> 클래스를 읽고 그 정보를 메모리에 올림 -> 클래스 필드나 클래스 메소드가 있으면 사용가능하게 함
- 클래스 필드는 static블록에서 초기화 가능 (static block)
- static블록은 main메소드보다 먼저 실행됨

3-5. 자바 메모리 설명 & 인스턴스 생성
- 시즌8부터는 meta space
- Java Heap은 JVM이 관리하는 메모리영역
- Native Memory는 운영체제가 관리하는 메모리영역
- 소스코드, 클래스 파일 자체는 정적임. 동적인 것들은 실행되면서 생성되는 것
- 클래스는 로딩될 때 메타스페이스에 로딩됨
- static 정보는 heap에 저장
- new 연산자 사용 -> 메모리에 인스턴스 생성/참조되는 것이 없으면 나중에 가비지 컬렉션이 됨
- static 필드는 클래스 로딩 시 딱 한 번 메모리에 올라가고 초기화
- 인스턴스 메소드는 인스턴스 생성 후 레퍼런스 변수를 이용해 사용
- 클래스 메소드는 클래스명.메소드명()으로 사용
- 메로드 안에 선언된 변수는 메소드 실행 시 메모리에 생성/종료 시 사라짐


3-6. 추상화란
: 중요한 건 남기고 불필요한 건 제거하는 것
- 캡슐화: 관련된 것을 잘 모아서 가지고 있는 것 / 캡슐화 된 정도 = 응집도

3-7. 좋은 객체 VS 나쁜 객체
- 좋은 객체 - 응집도는 높고, 결합도(coupling)는 낮다
: 역할과 책임에 충실하면서, 다른 객체와 잘 협력하여 동작하는 객체
// 나쁜 객체: 여러가지 역할을 한 객체에 부여하거나, 이름과는 맞지 않는 속성, 
             기능을 가지도록 하거나, 잘 동작하지 않는 객체, 다른 객체와도 동작이 매끄럽지 않는 객체
-> 구입한 물건 중에 좋은 물건은 뭘까..세탁기는 세탁을 잘해야 됨(부가적인 기능은 잘되고, 세탁이 안되면? 좋은 세탁기 아님..)
- 결합도가 낮아야 함 (부가적인 장비가 있어야만 잘 작동한다? -> 편리성이 낮아짐)
- 결합도가 높으면, 해당 객체만 사용하고 싶어도 부가적인 게 많아서 편리하지 않음

3-8. 다형성과 오버로딩
- 프로그램 언어의 다형성: 그 프로그래밍 언어의 자료형 체계의 성질
-> 언어의 각 요소(상수, 변수, 식, 오브젝트, 함수, 메소드 등)이 다양한 자료형이 속하는 것이 허가되는 성질
- 단형성: 프로그램 언어의 각 요소가 한가지 형태만 가지는 성질
ex) System.out.println - 클래스.필드.메소드/같은 이름의 메소드로 int, float, double~ 등이 인자로 올 수 있음
- println(int), println(double) 다 같은 pritnln메소드를 사용
-> 메소드 오버로딩: 메소드 이름은 같고, 매개변수의 개수, 타입이 다른 메소드를 정의하는 것
!리턴값만을 다르게 갖는 오버로딩은 작성 불가능
ex) public void println(boolean b){
        System.out.println(b);
    }
    public void println(double d){
        System.out.println(d);
    }
    public static void main(String[] args){
        StandardOutput output=new StandardOutput();
        output.println(true);
        output.println(10.5);
    }
    -> true/10.5 출력
    어렵게 만들더라도 사용할 때 쉽게 사용할 수 있게 객체를 만들어야 함!

3-9. package
 : 클래스는 패키지를 이용하여 관련 클래스를 관리함
   자바에서 패키지는 폴더와 거의 같은 기능을 제공함
- 클래스가 충돌하지 않도록 패키지 이름은 거꾸로 적은 도메인 + 모듈 이름으로 정의 권장
- 특정 패키지의 클래스를 사용할 때는 import 사용

3-10. 상속
: --는 --다. --는 --의 종류 중 하나다.라고 표현할 수 있다면 상속관계
    (ex.트럭은 자동차의 종류 중 하나다./자동차는 부모 클래스, 트럭은 자식 클래스)
- 여러 종류의 객체를 하나의 이름을 부르는 것 = 일반화 
-> 상속 = 일반화 + 확장
    (ex.포크레인=자동차+삽)
- 상속은 강한 결합이므로 반드시 써야할 때만 써야함(좋은 객체-응집도는 높고 결합도는 낮은 객체)
- [접근제한지][abstract][final] class 클래스명 extends 부모클래스명{클래스블록}
- 아무것도 상속받지 않으면 java.lang.Object를 자동으로 상속 =받음

3-11. 상속 - 부모타입으로 자식 인스턴스 참조되지
- Car car = new Bus(); -> Bus인스턴스를 car로 참조함

3-12. 상속 - 다형성(메소드 오버라이딩), 객체의 형변환
- 상위 클래스의 메소드를 하위 클래스가 재정의 하는 것
- 메소드의 이름, 파라미터의 개수, 타입도 동일해야 함
- 주로 상위 클래스의 동작을 상속받은 하위 클래스에서 변경하기 위해 사용
- 메소드가 오버라이딩 되면 무조건 자식 메소드가 실행됨.

3-13. 상속 - 필드, 메소드의 오버라이딩 할 때 주의점
- 필드는 타입을 따라가고, 메소드는 오버라이딩된 자식 메소드가 실행된다
- 정보 은닉은 객체 지향에서 중요한 기법이다. 
- 중요한 필드는 은닉하고, 필드는 메소드를 통해서만 접근해서 사용하도록 한다.(private 접근제한자 사용)
-> 외부에서 중요한 필드에 접근할 수 없도록 해야 함(메소드를 통해 사용해야 함)

3-14. 상속 - 필드, 프로퍼티, setter, getter 
- private필드를 접근하기 위해 제공하는 메소드를 setter, getter 사용(스프링에서는 프로퍼티라고도 함)
cf.this는 내 자신 인스턴스를 참조하는 예약어(클래스 메소드에서는 this 사용 불가능)
- ex)price는 지역변수, this.price는 인스턴스 변수
- geeter메소드를 이용해 값을 가공해 반환할 수 있음  

3-15. object의 오버라이딩을 위한 toString(), equals(), hashCode()메소드
- println(object x)로 정의한 타입이 매개변수로 사용됨
ex)Car 클래스 ->
 @override
 public String toString(){
    return "자동차"
 }
 ---------------------------
 main메소드->
 Car c1=new Car();
 System.out.println(c1)
 -> 자동차 출력
